#!/usr/bin/perl -w

package dbod_state_checker;

use strict;
use DBOD;
use DBOD::Database;
use POSIX ':sys_wait_h';

# Initializes Logging Settings

our ($logger, $lock_file); 

INIT{
    $logger = Log::Log4perl::get_logger( 'DBOD.StateChecker' );
    $logger->debug( 'Logger created' );
    $lock_file = $DBOD::config->{ 'SC_LOCK_FILE'};
}

sub usage() {
    print "USAGE:\n\t$0\n";
    exit -1;
}

sub worker {
    my ($instance, $pdbh) = @_;
    my $logger = Log::Log4perl::get_logger( "DBOD.worker" );

    my $worker_dbh;
    if (defined($pdbh)){
        # Cloning parent process DB handler
        $logger->debug("Cloning parent DB handler");
        $worker_dbh = $pdbh->clone();
        $logger->debug( "Setting date format: $DBOD::Database::DATEFORMAT" );
        $worker_dbh->do( "alter session set NLS_DATE_FORMAT='$DBOD::Database::DATEFORMAT'" );
        $pdbh->{InactiveDestroy} = 1;
        undef $pdbh;
    }
    else{
        # Obtaining a new DB connector
        $worker_dbh = DBOD::Database::getDBH();
    }

    $logger->debug( 'Checking ' . $instance->{ 'DB_NAME' } );
    
    my $state_checker = DBOD::get_state_checker($instance);
    if (!defined $state_checker){
        $logger->error( 'Not state checker defined for this DB type' );
        exit -1;
    }

    if (($instance->{'STATE'} ne 'JOB_PENDING') && 
        ($instance->{'STATE'} ne 'AWAITING_APPROVAL') &&
        ($instance->{'STATE'} ne 'MAINTENANCE')) {
        my ($buf, $instance_state) = $state_checker->($instance, 0);
        if (($instance->{'STATE'} ne $instance_state)) {
            $logger->debug( 'Updating STATE to ' . $instance_state . ' for ' . $instance->{ 'DB_NAME' });
            DBOD::Database::updateInstance($instance, 'STATE', $instance_state, $worker_dbh);
        }
    }
    else{
        $logger->debug( "State untouched for " . $instance->{'DB_NAME'} );
    }
   
    $worker_dbh->disconnect();
    exit 0;
}

sub Main{

    usage() if (@ARGV != 0);

    unless (-e $lock_file){

        $logger->debug( "Creating lock file: $lock_file" );
        open(LOCKF, ">$lock_file");
        close(LOCKF);
        $logger->debug( 'Opening DB connection' );
        my $dbh = DBOD::Database::getDBH();
        my $rc;

        if (defined($dbh)){
            my @instances = DBOD::Database::getInstanceList($dbh);
            my @tasks;

            foreach my $instance (@instances){
                if ($#tasks < 32){
                    my $worker_pid = fork();
                    if ($worker_pid){
                        $logger->debug( "Adding worker ($worker_pid) to pool" );
                        my $task = {};
                        $task->{'pid'} = $worker_pid;
                        $task->{'instance'} = $instance;
                        push(@tasks, $task);
                        $logger->debug( 'PID:' . $worker_pid . ' Instance ' . $instance->{'DB_NAME'} );
                    }                                                                                                 
                    else{
                        $logger->debug( 'Checking state for instance: ' . $instance->{'DB_NAME'} );
                        worker($instance, $dbh);
                        exit 0;
                    }
                }
                else { # Waiting in case the workers pool fills
                    $logger->debug( "Waiting for $#tasks tasks  completion" );
                    foreach my $task (@tasks) {
                        my $tmp = waitpid($task->{'pid'}, 0);
                        $logger->debug( "Done with worker : $tmp" );
                    }
                    $logger->debug( 'Removing finished workers from pool' );
                    @tasks = grep(waitpid($_->{'pid'}, 0)>=0, @tasks);
                }
 
            }

            # Waiting for workers to finish 
            #  - when the number of processes is less than MAX_PARALLEL_PROCS
            
            $logger->debug( "Waiting for $#tasks tasks  completion" );
            foreach my $task (@tasks) {
                my $tmp = waitpid($task->{'pid'}, 0);
                $logger->debug( "Done with worker : $tmp" );
            }

            # Everthing completed successfully
            $rc = 0;
        }
        else{
            $logger->error( 'Unable to get DB connection' );
            $rc = -1;
        }

        $logger->debug( 'Disconnecting from DB' );
        $dbh->disconnect();

        $logger->debug( 'Deleting lock file' );
        unlink $lock_file ;

        exit $rc;
    }
    else{
        $logger->debug("Another instance of dbod_state_checker is running.\n Skipping execution");
    }

}

&Main();

END{}

=head1 NAME

dbod_state_checker - State checker for DBOD instances

=cut

=head1 USE

=over

=item * 

dbod_state_checker

=back

=cut

=head1 COMMENTS

This is the script in charge of checking maintaining an updated
state for the DB instances in the DBOD application database.

Configuration and additional support files (i.e. templates for DBMS configuration files)
can be found at: <PATH_TO_PERL_SHARE>/DBOD/. Expected files are:

- dbod_daemon.conf : General configuration file. YAML format

- dbod_daemon_logger.conf : Logger configuration file

=head1 AUTHOR

Ignacio Coterillo <ignacio.coterillo[at]cern[dot]ch> 

IT-DB-DBB


=cut
